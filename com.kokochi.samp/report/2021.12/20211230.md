2021.12.30 트위치 클립쇼츠 데이터 가져오기 기본구현 완료
====================
## 트위치 클립쇼츠 데이터 실시간 가져오기
이전에 적용했던 클립쇼츠 데이터를 가져오기 위해서는, 팔로우 한 스트리머의 개수만큼 트위치 API로 통신을 보내야했다.     
이 때문에 한 스트리머의 데이터가 가져와질 때 까지 기다리고, 다음 데이터를 추가로 가져오기를 반복했기 때문에 상당히 오랜 시간이 걸렸다.     
테스트 스트리머 수 34명 기준 약 15초 정도의 시간이 걸렸다.     

이 부분을 쓰레드를 활용하여 속도개선을 하는 방법을 고민해 보았고, 이를 적용하였다.
````
	private static class ClipThread extends Thread{
		String stream;
		String query;
		List<ClipTwitchVO> res;
		HttpEntity entity;

		public ClipThread(String stream, String query, HttpEntity entity, List<ClipTwitchVO> res) {
			this.stream = stream;
			this.query = query;
			this.res = res;
			this.entity = entity;
		}

		@Override
		public void run() {
            ... 클립 데이터 가져오기 쿼리문
		}
	}
````
쓰레드 클래스를 상속하여 재정의한 run 메소드 안에서 클립 데이터를 가져오는 메소드를 작성한다.   
이 때 쿼리에 필요한 추가 데이터는 Thread 객체를 생성할 때 적용할 수 있도록 하여, 적용하였다.
최종적으로 결과 데이터는 res 리스트에 저장되어 반환한다.     

이렇게하면 기존 15초 정도 걸렸던 쿼리가 3초 이내에 처리되며, 상당한 속도 개선을 보일 수 있었다.     
이에 대해서 많은 사용자가 동시에 클립 쇼츠를 가져올 때 서버에 들어가게 되는 과부화적인 측면이나, 문제점들에 대해서는 추후에 정리가 필요할 듯 보인다.   
하지만 정상적인 서비스를 위해서는, 사실상 클립 쇼츠 한 번 데이터를 가져올 때 마다 15초씩 걸리는 것은 정상적인 서비스라고 보기 어렵기 때문에 당장은 쓰레드를 활용하여 데이터를 가져오는 방식이 맞는 것으로 보인다.     

````
for (String stream : streams) {
    ClipThread thread = new ClipThread(stream, query, entity, res);
    threadList.add(thread);
    thread.start();
}
for (ClipThread clipThread : threadList) {
    clipThread.join();
}
````
최종적으로 쓰레드를 실행한 후에, 모든 쓰레드가 끝날 때 까지 join을 통해, 기다리고, 최종적인 리스트를 반환해준다.     
![Alt text](../img/20211230-1.png)      
최종적으로 사용자 화면에서 정렬된 클립을 보여주고, 슬라이드를 추가하는 부분까지 구현을 완료하였다.     
이제 추가적으로 남은 부분은 클립 데이터를 정렬할 수 있는 정렬기준을 추가로 더 세워야한다.     
그리고 사용자 편의성을 위해 추가 스크립트 코딩이 필요할 예정이다.    
대표적으로 해당하는 클립 동영상이, 유튜브 쇼츠와 같이 영상이 표시될 때, 자동재생되고, 해당 영상을 넘기면 자동으로 영상이 멈추도록 하는 스크립트 작성이 필요한데, 해당 iframe을 조작하기 위해서는 또 다른 여러가지 스크립트들을 추가해야할 듯 보여서 추가적으로 시간이 더 걸릴 듯 하다.     
또한 사용자가 이미 본 클립은 다시 표시하지 않기 위해서, 화면을 넘겼을 때, ajax를 통해서 해당 영상이 이미 본 영상임을 db안에 저장하며, 해당 리스트는 다시 클립을 볼 때 표시하지 않도록 하는 부분을 추가해야한다.

## 다음 목표
* 클립쇼츠 데이터 정렬기준 세우기
* 영상 넘길 때 자동재생/멈춤 기능 추가
* 이미 본 영상은 다시 표시되지 않는 clipShorts_ban 테이블을 활용한 구현